{"version":3,"sources":["../../node_modules/notate/dist/index.js","../index.js","index.js"],"names":["notate","require","VALID_RESULT_TYPES","Object","seal","module","exports","replacers","options","recursive","resolve","clean","phraser","string","data","TypeError","replacements","replace","haystack","needle","replacement","trim","includes","result","reduce","replacer","length","isObject","assign","pop","patterns","obj"],"mappings":";AAAA,aAEA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAwBA,OAAA,QAAA,SAAA,GAEA,OADA,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,IACA,MAAA,KAAA,OAAA,SAAA,EAAA,GACA,MAAA,WAAA,EAAA,GAAA,EAAA,GAAA,GACA;;ACyDA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAlFA,IAAMA,EAASC,QAAQ,UAQjBC,EAAqBC,OAAOC,KAAK,CAAE,SAAU,WAcnDC,OAAOC,QAAU,WAAuBC,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAW,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAXA,EAAW,GAAA,UAAA,GAC5CC,IAAAA,EAAU,CACfC,WAAW,EACXC,SAAS,EACTC,OAAO,GAaCC,SAAAA,IAAQC,IAAAA,EAAS,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GAAIC,EAAuB,UAAA,OAAA,EAAA,UAAA,QAAA,EAChD,GAAkB,iBAAXD,EACJ,MAAA,IAAIE,UAA4EF,2DAAAA,OAAAA,EAAAA,GAAWA,MAAAA,OAAAA,EAAjG,MAGG,IAACC,EACGD,OAAAA,EAN8BG,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAc,IAAA,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAdA,EAAc,EAAA,GAAA,UAAA,GAmB3CC,SAAAA,EAAQC,EAAUC,GACpBC,IAAAA,EAAcZ,EAAQE,QAAUV,EAAOc,EAAMK,EAAOE,QAAUP,EAAKK,EAAOE,QAEzEnB,OAAAA,EAAmBoB,SAAgBF,EAAAA,IAAeA,EAAcZ,EAAQG,MAAQ,GAAKO,EAbzFhB,EAAmBoB,SAAgBR,EAAAA,MACtCA,EAASA,CAAAA,GAASE,OAAAA,IAebO,IAAAA,EAAShB,EAAUiB,OAAO,SAACX,EAAQY,GAAaZ,OAAAA,EAAOI,QAAQQ,EAAUR,IAAUJ,GAElF,OAACL,EAAQC,WAAaI,IAAWU,EAErCX,EAAA,WAAQW,EAAAA,CAAAA,EAAQT,GAASE,OAAAA,IADzBO,EAOGX,OA9CHL,EAAUmB,QAAUC,EAASpB,EAAUA,EAAUmB,OAAS,KAC7DvB,OAAOyB,OAAOpB,EAASD,EAAUsB,OA2ClCjB,EAAQkB,SAAWvB,EAEZK,GAQR,IAAMe,EAAW,SAAAI,GAAO,MAAa,oBAAb,GAAGA,OAAAA;;ACzE3B1B,OAAOC,QAAUL,QAAQ,MAARA,CAAe","file":"index.js","sourceRoot":"../src/hash","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Resolve dot notation strings\n *\n * @param  {Object} context     Object to start notation search (defaults to global scope)\n * @param  {String} [string=''] Dot notation representation\n * @return {Any}\t\t\t\tWhatever it finds / undefined\n *\n * @example\n * const obj = {\n *   top_level: {\n *     nested: {\n *       value: 'My Value'\n *     }\n *   }\n * };\n *\n * notate(obj, 'top_level.nested.value');\n * // 'My Value'\n *\n * notate(obj, 'top_level.missing.value');\n * // undefined\n */\nmodule.exports = function (source) {\n  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return string.split('.').reduce(function (previous, current) {\n    return _typeof(previous) === 'object' ? previous[current] : previous;\n  }, source);\n};\n","/**\n * @module paraphrase\n * @since 1.0.0\n */\n\nconst notate = require('notate');\n\n/**\n * Valid types of results for the interpolated string\n * @private\n * @type {Array}\n * @member {String|Number}\n */\nconst VALID_RESULT_TYPES = Object.seal([ 'string', 'number' ]);\n\n/**\n * Create new paraphrase method instance\n * @param  {...RegExp[]} replacers\n * @param  {Boolean}     [options.resolve=true] Should resolve dot notation within template\n * @param  {Boolean}     [options.clean=false]  Should remove unmatched template instances\n * @returns {Function} phraser function instance\n *\n * @example const phraser = paraphrase(/\\${([^{}]*)}/gm);\n *\n * phraser('Hello, ${name}', {name: 'Martin'})\n */\n\nmodule.exports = function paraphrase(...replacers) {\n\tconst options = {\n\t\trecursive: true,\n\t\tresolve: true,\n\t\tclean: false,\n\t};\n\tif (replacers.length && isObject(replacers[replacers.length - 1])) {\n\t\tObject.assign(options, replacers.pop());\n\t}\n\n\t/**\n\t * phraser description\n\t * @param  {String}                 string       Template\n\t * @param  {Object|(String|number)} data         Data for filling\n\t * @param  {...(String|number)}     replacements Replacement for filling\n\t * @return {String}                              Result\n\t */\n\tfunction phraser(string = '', data, ...replacements) {\n\t\tif (typeof string !== 'string') {\n\t\t\tthrow new TypeError(`paraphrase expects first argument to be a string, got a ${typeof string} (${string})`);\n\t\t}\n\n\t\tif (!data) {\n\t\t\treturn string;\n\t\t}\n\n\t\tif (VALID_RESULT_TYPES.includes(typeof data)) {\n\t\t\tdata = [ data, ...replacements ];\n\t\t}\n\n\t\t/**\n\t\t * Replace method build with internal reference to the passed in data structure\n\t\t * @param  {String} haystack The full string match\n\t\t * @param  {String} needle   The content to identify as data member\n\t\t * @return {String}         Found value\n\t\t */\n\t\tfunction replace(haystack, needle) {\n\t\t\tconst replacement = options.resolve ? notate(data, needle.trim()) : data[needle.trim()];\n\n\t\t\treturn VALID_RESULT_TYPES.includes(typeof replacement) ? replacement : options.clean ? '' : haystack;\n\t\t}\n\n\t\tconst result = replacers.reduce((string, replacer) => string.replace(replacer, replace), string);\n\n\t\treturn !options.recursive || string === result\n\t\t\t?\tresult\n\t\t\t: phraser(result, data, ...replacements)\n\t\t;\n\t}\n\n\tphraser.patterns = replacers;\n\n\treturn phraser;\n};\n\n/**\n * Is this a basic object?\n * @param  {any} obj\n * @return {boolean}\n */\nconst isObject = obj => `${obj}` === '[object Object]';\n","/**\n * @module hash\n * @since 1.1.0\n */\n\n/**\n * A paraphraser: Replace method build with internal reference to the passed in data structure\n * @param  {String} haystack The full string match\n * @param  {String} needle   The content to identify as data member\n * @return {String}          Found value\n *\n * @example\n * hash('Hello, #{name}', {name: 'Martin'}) // 'Hello, Martin'\n */\nmodule.exports = require('../')(/#{([^{}]*)}/gm);\n"]}